# API Design Guide

## Standard Naming Rule 
TODO

## HTTP Status Code
#### 2XX Success
2xx 상태 코드들은 서버가 클라이언트의 요청을 성공적으로 처리했다는 의미로 사용된다.

##### 200 OK
| 클라이언트의 요청을 서버가 정상적으로 처리했다.
성공에 대한 모든 상태 코드를 200으로 응답해도 크게 상관없다. 200 코드 대부분이 클라이언트에게 요청이 성공했다는 것을 응답하는 기능을 갖기 때문이다.
실제로도 많은 REST API에서 2xx 상태 코드를 세분화하여 사용하지 않는다.
그러나 클라이언트에게 더 정확하고 자세한 정보를 제공하기 위해선 적절한 상태 코드를 보내는 것이 좋다. 이를 지원하기 위해, 2xx 상태 코드들은 각각 세분화된 목적을 갖는다.

아래 예는 Worst Practice이다. 설계시 주의한다.
```
HTTP/1.1 200 OK
{
  "status" : 400
  "result" : false  
}
```
상태 코드는 200으로 성공인데 body 내용엔 실패에 관한 내용을 리턴하고 있다. 모든 응답을 200으로 처리하고 body 내용으로 성공|실패를 판단하는 구조에서 사용된다.
API가 아닌 HTML 웹 프로젝트에서 대부분 이렇게 사용한다. 웹의 설계를 그대로 사용하는 경우에 발생하는 문제에 해당한다.


##### 201 Created
| 클라이언트의 요청을 서버가 정상적으로 처리하여 새로운 리소스가 생겼다.

201 상태 코드는 POST 요청에 대한 응답에 주로 사용된다.
클라이언트의 요청이 성공적으로 이뤄졌다는 의미까지는 200과 동일한데, 성공과 동시에 새로운 리소스가 생성되었다는 의미를 포함한다.
물론 새로운 리소스를 생성하는 POST, PUT 요청의 응답으로 200을 보내줘도 된다. 또한 아직 많은 API의 상태 코드가 이렇게 응답한다.

하지만, 더 정확한 의미를 전달하기 위해 201 상태 코드를 쓸 것을 추천하며, 이때 HTTP 헤더의 Content-Location를 이용하여 만들어진 리소스 생성된 위치를 알려주면 좋다.
```aidl
HTTP/1.1 201 Created
Content-Location: /accounts/1
{
    "user_id" : 1,
    "name" : "jaeeun"
}
```

다만, `HATEOAS`로 Content-Location을 대체할 수 있다.

##### 202 Accepted
| 클라이언트의 요청은 정상적이나, 서버가 아직 요청을 완료하지 못했다.

클라이언트의 요청이 정상적이면 서버에선 작업의 성공|실패 응답하는 게 일반적이나, 작업 완료를 위한 일련의 작업들이 오래 걸리기 때문에 나중에 알려주겠다는 의미로 사용된다.
주로 비동기 처리 시에 구현되며, 이때 중요한 것은 작업의 확인 방법이다. 비동기 작업은 해당 요청이 언제 완료되는지 알 수 없으므로
클라이언트가 요청의 완료 여부를 확인할 수 있는 방법을 제공해야 한다. 일반적으로 아래 두 가지 방식이 사용된다.

- Callback
- Polling

##### 204 No Content
| 클라이언트의 요청은 정상적이다. 그러나 리소스를 제공하지는 않는다.

자원 삭제 요청이 들어왔을 때, 이 요청이 유효하다면 서버는 해당 자원을 삭제한다. 이후 더이상 제공할 리소스가 없으므로 204로 응답한다.
204로 응답하는 경우, Http Response Body가 아예 존재하지 않는다.
200으로 응답하고 Http Response Body에 null, {}, [], false 등을 채워서 보내는 것과는 다르다.


#### 4XX Client errors
4XX의 상태 코드들은 클라이언트의 요청이 유효하지 않아 서버가 해당 요청을 수행하지 않았다는 의미다.

##### 400 Bad Request
| 클라이언트의 요청이 유효하지 않아 더 이상 작업을 진행하지 않는다.

##### 401 Unauthorized
| 클라이언트가 인증되지 않았기 때문에 작업을 진행할 수 없다.
인증에 관한 것으로, 401은 비인증된 상태를 의미한다. `Unauthenticated`가 더 적합하지만, Unauthorized로 사용되고 있으므로 참고한다.

##### 403 Forbidden
| 클라이언트가 권한이 없기 때문에 작업을 진행할 수 없다.
인증은 되었으나, 해당 리소스에 접근할 권한이 없을 때 응답하는 상태 코드이다.

##### 404 Not Found
| 클라이언트가 요청한 리소스가 존재하지 않는다.
크게 두 가지 상태에 대해 404로 응답한다.
1. 라우팅 리소스(경로)가 존재하지 않는 경우
2. 개별 리소스가 존재하지 않는 경우

대부분의 API Framework에서는 경로에 대한 에러 처리는 자동으로 404 응답을 리턴하지만, 리소스의 경우는 지원하지 않으므로 코드 레벨에서 직접 처리해야 한다.
모든 리소스 대상 요청의 경우, 해당 리소스가 존재하는지 파악 후 후속 처리를 진행해야 하며, 그렇지 않을 경우 후속 작업에서 5XX 오류로 이어질 수 있다.

##### 405 Method Not Allowed
| 클라이언트의 요청이 허용되지 않는 메소드인 경우

리소스는 존재하지만, 해당 리소스가 지원하지 않는 메소드일 때 응답한다.

이를 위해 OPTIONS 메소드를 유용하게 사용할 수 있는데, OPTIONS는 API가 허용하는 메소드가 어떤 것들이 있는지 확인하는 메소드다.
405 오류를 사전에 방지하기 위한 용도에 주로 쓰인다.
이 때 응답 HTTP header의 Allow에 지원하는 메소드를 나열하여 응답한다.

RESTful API 설계 가이드에서도 말한 내용이지만 완성도 높은 API를 위해 제공하길 추천한 다.
(최근 몇몇 API 프레임워크에선 자동으로 허용되지 않는 메소드에 대해 405 상태 코드와 Allow 헤더를 응답하기도 한다.)

```OPTIONS /users/1 HTTP/1.1
HTTP/1.1 200 OK
Allow: GET,PUT,DELETE,OPTIONS,HEAD
```

/users/1 자원은 POST 메소드를 제공하지 않는다는 정보를 확인할 수 있다.

##### 409 Conflict
| 클라이언트의 요청이 서버의 상태와 충돌하여, 처리할 수 없다.

요청이 비즈니스 로직과 모순이 발생하여 처리할 수 없는 상태에 해당한다.
예를 들어 보호 상태에 있는 리소스를 삭제하려고 요청했거나, 수정 가능 기간이 지나 더이상 수정할 수 없는 리소스를 수정하려고 할 때 이 상태코드를 응답한다.

##### 429 Too many Requests
| 클라이언트가 일정 시간 동안 너무 많은 요청을 보낸 경우

429 상태 코드는 일정 시간 뒤 요청할 것을 나타내는 것이다. 로그인의 경우, 잦은 실패는 해킹 시도로 의심할 수 있다.
따라서 일정 범위를 벗어나는 계속된 요청은 429로 처리하고, 일정 시간 동안 응답을 하지 않는다.
응답 시에는 다음과 같이 HTTP hearder Retry-After을 이용한다.

```
HTTP/1.1 429 Too Many Requests
Retry-After: 3600
```


#### 5XX Client errors
| 서버 오류로 인해 요청을 수행할 수 없다는 의미

API 서버의 응답이 5XX 오류를 발생시키도록 설계해서는 안된다. 5XX 오류는 비정상적인 응답이므로 예외 처리가 제대로 되지 않았다는 뜻이며,
모니터링 시스템에서 5XX 오류가 자주 발생할 경우 시스템 운영 장애로 간주해야 한다. 
